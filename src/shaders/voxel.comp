#version 440 core

// For fixing floating point errors
#define EPSILON 0.0001
#define INV_GAMMA 0.4545
#define AA_SAMPLES 1
#define NUM_BOUNCES 3

layout(local_size_x = 10, local_size_y = 10) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform uvec3 mapSize;
uniform uint frame;

uniform mat4 invView;
uniform mat4 invCenteredView;
uniform mat4 invProjection;

// Sky color example from Ray Tracing In One Weekend
vec3 skyColor(vec3 rayPos, vec3 rayDir) {
    float t = 0.5 * (rayDir.y + 1);
    return (1 - t) * vec3(1) + t * vec3(0.5, 0.7, 1.0);
}

vec2 intersectBox(vec3 rayPos, vec3 invRayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayPos) * invRayDir;
    vec3 tMax = (boxMax - rayPos) * invRayDir;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar  = min(min(t2.x, t2.y), t2.z);

    return vec2(tNear, tFar);
}

// random stuff taken from https://www.shadertoy.com/view/tsBBWW
const float pi = 3.14159265359f;
const float twoPi = 2 * pi;

uint wangHash(inout uint seed) {
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

float randomFloat(inout uint state) {
    return float(wangHash(state)) / 4294967296.0;
}

vec3 randomUnitVector(inout uint state) {
    float z = randomFloat(state) * 2.0f - 1.0f;
    float a = randomFloat(state) * twoPi;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

struct VoxelHit {
    vec3 position;
    vec3 normal;
    vec3 color;
    bool hit;
    bool metal;
};

bool inVoxelBuffer(ivec3 vx) {
    return (vx.x >= 0 && vx.x < mapSize.x) &&
    (vx.y >= 0 && vx.y < mapSize.y) &&
    (vx.z >= 0 && vx.z < mapSize.z);
}

VoxelHit traceVoxel(vec3 rayPos, vec3 rayDir) {
    vec3 pos = floor(rayPos);
    vec3 step = sign(rayDir);
    vec3 tDelta = step / rayDir;

    float tMaxX, tMaxY, tMaxZ;
    vec3 fr = fract(rayPos);

    tMaxX = tDelta.x * ((rayDir.x > 0) ? (1.0 - fr.x) : fr.x);
    tMaxY = tDelta.y * ((rayDir.y > 0) ? (1.0 - fr.y) : fr.y);
    tMaxZ = tDelta.z * ((rayDir.z > 0) ? (1.0 - fr.z) : fr.z);

    vec3 norm;
    vec3 hitPos;
    const int maxTrace = 150;
    float dist;

    VoxelHit hit;
    hit.hit = false;
    hit.metal = false;

    for (int i = 0; i < maxTrace; ++i) {
        if (inVoxelBuffer(ivec3(pos))) {
            const float sphereRadius = 14;
            if (length(pos - vec3(16)) < sphereRadius && ivec3(pos) % 2 == 0) {
                hit.position = rayPos + (dist - EPSILON) * rayDir;
                hit.normal = norm;
                hit.hit = true;
                hit.color = (pos - vec3(16)) / (2 * sphereRadius) + 0.6;
                //hit.metal = true;
                //hit.color = vec3(1);
                break;
            } else if (pos.y <= 2) {
                hit.position = rayPos + (dist - EPSILON) * rayDir;
                hit.normal = norm;
                hit.hit = true;
                hit.color = vec3(0.2);
                hit.metal = true;
                break;
            }
        }

        if (tMaxX < tMaxY) {
            if (tMaxZ < tMaxX) {
                dist = tMaxZ;
                tMaxZ += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0,-step.z);
            } else {
                dist = tMaxX;
                tMaxX += tDelta.x;
                pos.x += step.x;
                norm = vec3(-step.x, 0, 0);
            }
        } else {
            if (tMaxZ < tMaxY) {
                dist = tMaxZ;
                tMaxZ += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0, -step.z);
            } else {
                dist = tMaxY;
                tMaxY += tDelta.y;
                pos.y += step.y;
                norm = vec3(0, -step.y, 0);
            }
        }
    }

    return hit;
}

vec4 traceRay(vec3 rayPos, vec3 rayDir, inout uint rngState) {
    vec3 invRayDir = 1.0 / rayDir;
    vec2 intersection = intersectBox(rayPos, invRayDir, vec3(0, 0, 0), mapSize);

    // Ray hits the voxel box
    if (intersection.x <= intersection.y) {
        // Advance ray start to box
        if (intersection.x > 0) {
            //FIXME: this makes noise glitches more visible instead of only improving performance
            //FIXME: also glitches at the chunk borders
            //rayPos += rayDir * (intersection.x + EPSILON);
        }

        VoxelHit hit;
        vec4 color = vec4(1, 1, 1, 0);

        for (int depth = 0; depth < NUM_BOUNCES; ++depth) {
            hit = traceVoxel(rayPos, rayDir);
            if (hit.hit) {
                if (depth == 0) {
                    color.w = length(hit.position - rayPos);
                }

                color = color * vec4(hit.color, 1);

                if (hit.metal) {
                    vec3 reflected = reflect(normalize(rayDir), hit.normal);
                    if (dot(reflected, hit.normal) > 0) {
                        rayPos = hit.position;
                        rayDir = reflected;
                    } else {
                        return color * vec4(0, 0, 0, 1);
                    }
                } else {
                    rayPos = hit.position;
                    rayDir = hit.normal + randomUnitVector(rngState);
                }
            } else {
                color = color * vec4(skyColor(rayPos, rayDir), 1);
                return color;
            }
        }

        return color;
    } else {
        return vec4(skyColor(rayPos, rayDir), 0);
    }
}


void main() {
    ivec2 outputCoords = ivec2(gl_GlobalInvocationID.xy);

    uint rngState = uint(outputCoords.x) * 1973 + uint(outputCoords.y) * 9277 + frame * 26699 | 1;
    vec3 rayPos = (invView * vec4(0, 0, 0, 1)).xyz;
    vec4 outputColor = vec4(0);

    for (int aa = 0; aa < AA_SAMPLES; ++aa) {
        vec2 randomOffset = vec2(randomFloat(rngState), randomFloat(rngState));
        vec2 screenCoords = (vec2(outputCoords) + randomOffset) / vec2(imageSize(outputImage)) * 2 - 1;
        vec3 rayDir = normalize((invCenteredView * invProjection * vec4(screenCoords, 0, 1)).xyz) + EPSILON;

        outputColor += traceRay(rayPos, rayDir, rngState);
    }

    vec4 aaColor = outputColor / AA_SAMPLES;
    vec3 gammaCorrectedColor = pow(aaColor.xyz, vec3(INV_GAMMA));
    imageStore(outputImage, outputCoords, vec4(gammaCorrectedColor, aaColor.w));
}